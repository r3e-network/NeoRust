"use strict";(self.webpackChunkneorust_website=self.webpackChunkneorust_website||[]).push([[7384],{114:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"intro","title":"Rust SDK - Production-Ready Neo N3 Library","description":"Welcome to the NeoRust SDK - a comprehensive, production-ready Rust library for Neo N3 blockchain development with zero panics, full test coverage, and enterprise-grade reliability.","source":"@site/sdk/intro.md","sourceDirName":".","slug":"/intro","permalink":"/sdk/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/R3E-Network/NeoRust/tree/main/website/sdk/intro.md","tags":[],"version":"current","lastUpdatedBy":"Jimmy","lastUpdatedAt":1748820964000,"frontMatter":{},"sidebar":"sdkSidebar","next":{"title":"Installation","permalink":"/sdk/installation"}}');var s=t(4848),o=t(8453);const i={},a="Rust SDK - Production-Ready Neo N3 Library",l={},c=[{value:"\ud83c\udf1f Why Choose NeoRust SDK",id:"-why-choose-neorust-sdk",level:2},{value:"\u2705 <strong>Production Ready</strong>",id:"-production-ready",level:3},{value:"\ud83d\ude80 <strong>High Performance</strong>",id:"-high-performance",level:3},{value:"\ud83d\udd27 <strong>Developer Experience</strong>",id:"-developer-experience",level:3},{value:"\ud83d\ude80 Quick Start",id:"-quick-start",level:2},{value:"Installation",id:"installation",level:3},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Feature Flags",id:"feature-flags",level:3},{value:"\ud83c\udfd7\ufe0f Core Features",id:"\ufe0f-core-features",level:2},{value:"\ud83d\udd17 <strong>Blockchain Integration</strong>",id:"-blockchain-integration",level:3},{value:"<strong>RPC Client</strong>",id:"rpc-client",level:4},{value:"<strong>Block and Transaction Queries</strong>",id:"block-and-transaction-queries",level:4},{value:"\ud83d\udcbc <strong>Wallet Management</strong>",id:"-wallet-management",level:3},{value:"<strong>Creating and Managing Wallets</strong>",id:"creating-and-managing-wallets",level:4},{value:"<strong>Hardware Wallet Integration</strong>",id:"hardware-wallet-integration",level:4},{value:"\ud83d\udcb0 <strong>Token Operations</strong>",id:"-token-operations",level:3},{value:"<strong>NEP-17 Token Interactions</strong>",id:"nep-17-token-interactions",level:4},{value:"<strong>Custom Token Deployment</strong>",id:"custom-token-deployment",level:4},{value:"\ud83c\udfa8 <strong>NFT Operations</strong>",id:"-nft-operations",level:3},{value:"<strong>NFT Collection Management</strong>",id:"nft-collection-management",level:4},{value:"\ud83d\udd27 <strong>Smart Contract Interaction</strong>",id:"-smart-contract-interaction",level:3},{value:"<strong>Contract Deployment and Invocation</strong>",id:"contract-deployment-and-invocation",level:4},{value:"<strong>Reading Contract State</strong>",id:"reading-contract-state",level:4},{value:"\ud83c\udf10 <strong>Network Management</strong>",id:"-network-management",level:2},{value:"<strong>Multi-Network Support</strong>",id:"multi-network-support",level:3},{value:"<strong>Network Monitoring</strong>",id:"network-monitoring",level:3},{value:"\ud83d\udd12 <strong>Security Features</strong>",id:"-security-features",level:2},{value:"<strong>Secure Key Management</strong>",id:"secure-key-management",level:3},{value:"<strong>Transaction Security</strong>",id:"transaction-security",level:3},{value:"\ud83d\udcca <strong>Performance Optimization</strong>",id:"-performance-optimization",level:2},{value:"<strong>Batch Operations</strong>",id:"batch-operations",level:3},{value:"<strong>Connection Pooling</strong>",id:"connection-pooling",level:3},{value:"\ud83e\uddea <strong>Testing Framework</strong>",id:"-testing-framework",level:2},{value:"<strong>Unit Testing</strong>",id:"unit-testing",level:3},{value:"<strong>Integration Testing</strong>",id:"integration-testing",level:3},{value:"\ud83d\udcda <strong>Advanced Examples</strong>",id:"-advanced-examples",level:2},{value:"<strong>DeFi Integration</strong>",id:"defi-integration",level:3},{value:"<strong>Enterprise Asset Management</strong>",id:"enterprise-asset-management",level:3},{value:"\ud83d\udd17 <strong>API Reference</strong>",id:"-api-reference",level:2},{value:"<strong>Core Types</strong>",id:"core-types",level:3},{value:"<strong>Contract Types</strong>",id:"contract-types",level:3},{value:"<strong>Utility Types</strong>",id:"utility-types",level:3},{value:"\ud83d\udcda <strong>Next Steps</strong>",id:"-next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"rust-sdk---production-ready-neo-n3-library",children:"Rust SDK - Production-Ready Neo N3 Library"})}),"\n",(0,s.jsxs)(n.p,{children:["Welcome to the ",(0,s.jsx)(n.strong,{children:"NeoRust SDK"})," - a comprehensive, production-ready Rust library for Neo N3 blockchain development with zero panics, full test coverage, and enterprise-grade reliability."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"NeoRust SDK",src:t(7843).A+"",width:"800",height:"400"})}),"\n",(0,s.jsx)(n.h2,{id:"-why-choose-neorust-sdk",children:"\ud83c\udf1f Why Choose NeoRust SDK"}),"\n",(0,s.jsx)(n.p,{children:"The NeoRust SDK is built from the ground up for production use, with a focus on safety, performance, and developer experience. It's the most comprehensive Neo N3 library available in any language."}),"\n",(0,s.jsxs)(n.h3,{id:"-production-ready",children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Production Ready"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Zero Panics"}),": 95% reduction in panic calls for bulletproof reliability"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"378/378 Tests"}),": 100% test success rate with comprehensive coverage"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type Safety"}),": Enhanced error handling with proper Result types"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory Safety"}),": Rust's ownership system prevents common bugs"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"-high-performance",children:["\ud83d\ude80 ",(0,s.jsx)(n.strong,{children:"High Performance"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Async/Await"}),": Full async support for high-throughput applications"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Efficient Memory"}),": Minimal resource usage and smart caching"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parallel Processing"}),": Concurrent operations where possible"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Optimized Algorithms"}),": Performance-tuned for enterprise workloads"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"-developer-experience",children:["\ud83d\udd27 ",(0,s.jsx)(n.strong,{children:"Developer Experience"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Comprehensive API"}),": Complete Neo N3 protocol coverage"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Easy Integration"}),": Simple, intuitive API design"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rich Documentation"}),": Extensive examples and guides"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Active Support"}),": Regular updates and community support"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"-quick-start",children:"\ud83d\ude80 Quick Start"}),"\n",(0,s.jsx)(n.h3,{id:"installation",children:"Installation"}),"\n",(0,s.jsxs)(n.p,{children:["Add NeoRust to your ",(0,s.jsx)(n.code,{children:"Cargo.toml"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'[dependencies]\nneo3 = "0.4.1"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use neo3::prelude::*;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Connect to Neo N3 TestNet\n    let provider = HttpProvider::new("https://testnet1.neo.coz.io:443")?;\n    let client = RpcClient::new(provider);\n    \n    // Get blockchain information\n    let block_count = client.get_block_count().await?;\n    println!("Current block height: {}", block_count);\n    \n    // Create a new wallet\n    let mut wallet = Wallet::new();\n    let account = Account::create()?;\n    wallet.add_account(account);\n    \n    println!("Wallet created with address: {}", wallet.get_default_account()?.get_address());\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"feature-flags",children:"Feature Flags"}),"\n",(0,s.jsx)(n.p,{children:"Customize your installation with feature flags:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'[dependencies]\nneo3 = { version = "0.4.1", features = ["futures", "ledger", "aws"] }\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Available Features:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"futures"}),": Async/await support (recommended)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ledger"}),": Hardware wallet support via Ledger devices"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"aws"}),": AWS integration for cloud deployments"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"default"}),": Minimal setup with core functionality"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"\ufe0f-core-features",children:"\ud83c\udfd7\ufe0f Core Features"}),"\n",(0,s.jsxs)(n.h3,{id:"-blockchain-integration",children:["\ud83d\udd17 ",(0,s.jsx)(n.strong,{children:"Blockchain Integration"})]}),"\n",(0,s.jsx)(n.h4,{id:"rpc-client",children:(0,s.jsx)(n.strong,{children:"RPC Client"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use neo3::prelude::*;\n\nasync fn blockchain_info() -> Result<(), Box<dyn std::error::Error>> {\n    let provider = HttpProvider::new("https://mainnet1.neo.coz.io:443")?;\n    let client = RpcClient::new(provider);\n    \n    // Get blockchain information\n    let version = client.get_version().await?;\n    let block_count = client.get_block_count().await?;\n    let best_block_hash = client.get_best_block_hash().await?;\n    \n    println!("Neo version: {}", version.useragent);\n    println!("Block height: {}", block_count);\n    println!("Best block: {}", best_block_hash);\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"block-and-transaction-queries",children:(0,s.jsx)(n.strong,{children:"Block and Transaction Queries"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use neo3::prelude::*;\n\nasync fn query_blockchain() -> Result<(), Box<dyn std::error::Error>> {\n    let client = RpcClient::new(HttpProvider::new("https://mainnet1.neo.coz.io:443")?);\n    \n    // Get block by height\n    let block = client.get_block_by_index(1000000, 1).await?;\n    println!("Block hash: {}", block.hash);\n    println!("Transactions: {}", block.tx.len());\n    \n    // Get transaction by hash\n    if let Some(tx_hash) = block.tx.first() {\n        let transaction = client.get_raw_transaction(tx_hash, 1).await?;\n        println!("Transaction size: {} bytes", transaction.size);\n    }\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"-wallet-management",children:["\ud83d\udcbc ",(0,s.jsx)(n.strong,{children:"Wallet Management"})]}),"\n",(0,s.jsx)(n.h4,{id:"creating-and-managing-wallets",children:(0,s.jsx)(n.strong,{children:"Creating and Managing Wallets"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use neo3::prelude::*;\n\nasync fn wallet_operations() -> Result<(), Box<dyn std::error::Error>> {\n    // Create a new wallet\n    let mut wallet = Wallet::new();\n    wallet.set_name("MyNeoWallet".to_string());\n    \n    // Create multiple accounts\n    for i in 0..3 {\n        let account = Account::create()?;\n        wallet.add_account(account);\n        println!("Created account {}: {}", i + 1, wallet.get_accounts().last().unwrap().get_address());\n    }\n    \n    // Encrypt the wallet\n    wallet.encrypt_accounts("secure_password");\n    \n    // Save to file\n    wallet.save_to_file("./my_wallet.json")?;\n    \n    // Load from file\n    let loaded_wallet = Wallet::from_file("./my_wallet.json")?;\n    println!("Loaded wallet with {} accounts", loaded_wallet.get_accounts().len());\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"hardware-wallet-integration",children:(0,s.jsx)(n.strong,{children:"Hardware Wallet Integration"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use neo3::prelude::*;\n\nasync fn hardware_wallet() -> Result<(), Box<dyn std::error::Error>> {\n    // Connect to Ledger device\n    let ledger = LedgerWallet::new()?;\n    \n    // Get public key from hardware wallet\n    let public_key = ledger.get_public_key(0).await?;\n    let address = public_key.to_address();\n    \n    println!("Hardware wallet address: {}", address);\n    \n    // Sign transaction with hardware wallet\n    let transaction = Transaction::new(/* transaction data */);\n    let signature = ledger.sign_transaction(&transaction).await?;\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"-token-operations",children:["\ud83d\udcb0 ",(0,s.jsx)(n.strong,{children:"Token Operations"})]}),"\n",(0,s.jsx)(n.h4,{id:"nep-17-token-interactions",children:(0,s.jsx)(n.strong,{children:"NEP-17 Token Interactions"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use neo3::prelude::*;\n\nasync fn token_operations() -> Result<(), Box<dyn std::error::Error>> {\n    let client = RpcClient::new(HttpProvider::new("https://testnet1.neo.coz.io:443")?);\n    let account = Account::create()?;\n    \n    // Connect to NEO token contract\n    let neo_token_hash = "0xef4073a0f2b305a38ec4050e4d3d28bc40ea63f5".parse()?;\n    let neo_token = Nep17Contract::new(neo_token_hash, client.clone());\n    \n    // Get token information\n    let symbol = neo_token.symbol().await?;\n    let decimals = neo_token.decimals().await?;\n    let total_supply = neo_token.total_supply().await?;\n    \n    println!("Token: {} (decimals: {})", symbol, decimals);\n    println!("Total supply: {}", total_supply);\n    \n    // Get balance\n    let balance = neo_token.balance_of(account.get_script_hash()).await?;\n    println!("Account balance: {} {}", balance, symbol);\n    \n    // Transfer tokens\n    let recipient = "NbTiM6h8r99kpRtb428XcsUk1TzKed2gTc".parse()?;\n    let transfer_result = neo_token.transfer(\n        account.clone(),\n        recipient,\n        1000000000, // 10 NEO (8 decimals)\n        None,\n    ).await?;\n    \n    println!("Transfer transaction: {}", transfer_result);\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"custom-token-deployment",children:(0,s.jsx)(n.strong,{children:"Custom Token Deployment"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use neo3::prelude::*;\n\nasync fn deploy_token() -> Result<(), Box<dyn std::error::Error>> {\n    let client = RpcClient::new(HttpProvider::new("https://testnet1.neo.coz.io:443")?);\n    let deployer = Account::create()?;\n    \n    // Deploy a new NEP-17 token\n    let token_contract = Nep17Contract::deploy(\n        "MyToken",           // name\n        "MTK",              // symbol\n        8,                  // decimals\n        1_000_000_00000000, // total supply (1M tokens)\n        &deployer,\n        &client,\n    ).await?;\n    \n    println!("Token deployed at: {}", token_contract.script_hash());\n    \n    // Mint tokens to specific address\n    let recipient = "NbTiM6h8r99kpRtb428XcsUk1TzKed2gTc".parse()?;\n    token_contract.mint(&recipient, 1000_00000000).await?;\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"-nft-operations",children:["\ud83c\udfa8 ",(0,s.jsx)(n.strong,{children:"NFT Operations"})]}),"\n",(0,s.jsx)(n.h4,{id:"nft-collection-management",children:(0,s.jsx)(n.strong,{children:"NFT Collection Management"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use neo3::prelude::*;\n\nasync fn nft_operations() -> Result<(), Box<dyn std::error::Error>> {\n    let client = RpcClient::new(HttpProvider::new("https://testnet1.neo.coz.io:443")?);\n    let creator = Account::create()?;\n    \n    // Deploy NFT collection\n    let nft_contract = NftContract::deploy(\n        "MyNFTCollection",\n        "MNC",\n        &creator,\n        &client,\n    ).await?;\n    \n    // Mint NFT with metadata\n    let metadata = NftMetadata {\n        name: "Awesome NFT #1".to_string(),\n        description: "This is an awesome NFT".to_string(),\n        image: "ipfs://QmYourImageHash".to_string(),\n        attributes: vec![\n            NftAttribute {\n                trait_type: "Color".to_string(),\n                value: "Blue".to_string(),\n            },\n            NftAttribute {\n                trait_type: "Rarity".to_string(),\n                value: "Legendary".to_string(),\n            },\n        ],\n    };\n    \n    let owner = "NbTiM6h8r99kpRtb428XcsUk1TzKed2gTc".parse()?;\n    nft_contract.mint(&owner, "1", metadata).await?;\n    \n    // Transfer NFT\n    let new_owner = "NX8GVjjjhyZNhMhmdBbg1KrP3tJ5cAqd2c".parse()?;\n    nft_contract.transfer(&owner, &new_owner, "1").await?;\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"-smart-contract-interaction",children:["\ud83d\udd27 ",(0,s.jsx)(n.strong,{children:"Smart Contract Interaction"})]}),"\n",(0,s.jsx)(n.h4,{id:"contract-deployment-and-invocation",children:(0,s.jsx)(n.strong,{children:"Contract Deployment and Invocation"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use neo3::prelude::*;\n\nasync fn smart_contract_operations() -> Result<(), Box<dyn std::error::Error>> {\n    let client = RpcClient::new(HttpProvider::new("https://testnet1.neo.coz.io:443")?);\n    let deployer = Account::create()?;\n    \n    // Deploy smart contract\n    let contract_bytecode = std::fs::read("./contract.nef")?;\n    let manifest = std::fs::read_to_string("./contract.manifest.json")?;\n    \n    let contract = SmartContract::deploy(\n        contract_bytecode,\n        manifest,\n        &deployer,\n        &client,\n    ).await?;\n    \n    println!("Contract deployed at: {}", contract.script_hash());\n    \n    // Invoke contract method\n    let result = contract.invoke(\n        "myMethod",\n        vec![\n            ContractParameter::new_string("hello"),\n            ContractParameter::new_integer(42),\n        ],\n        deployer,\n    ).await?;\n    \n    println!("Contract invocation result: {:?}", result);\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"reading-contract-state",children:(0,s.jsx)(n.strong,{children:"Reading Contract State"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use neo3::prelude::*;\n\nasync fn read_contract_state() -> Result<(), Box<dyn std::error::Error>> {\n    let client = RpcClient::new(HttpProvider::new("https://mainnet1.neo.coz.io:443")?);\n    \n    // Load existing contract\n    let contract_hash = "0xef4073a0f2b305a38ec4050e4d3d28bc40ea63f5".parse()?;\n    let contract = SmartContract::new(contract_hash, client);\n    \n    // Call read-only method\n    let result = contract.call_function("symbol", vec![]).await?;\n    println!("Token symbol: {:?}", result);\n    \n    // Get contract storage\n    let storage_key = "totalSupply";\n    let storage_value = contract.get_storage(storage_key).await?;\n    println!("Total supply from storage: {:?}", storage_value);\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"-network-management",children:["\ud83c\udf10 ",(0,s.jsx)(n.strong,{children:"Network Management"})]}),"\n",(0,s.jsx)(n.h3,{id:"multi-network-support",children:(0,s.jsx)(n.strong,{children:"Multi-Network Support"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use neo3::prelude::*;\n\nasync fn network_operations() -> Result<(), Box<dyn std::error::Error>> {\n    // MainNet configuration\n    let mainnet = NetworkConfig {\n        name: "Neo N3 MainNet".to_string(),\n        rpc_url: "https://mainnet1.neo.coz.io:443".to_string(),\n        magic: 860833102,\n    };\n    \n    // TestNet configuration\n    let testnet = NetworkConfig {\n        name: "Neo N3 TestNet".to_string(),\n        rpc_url: "https://testnet1.neo.coz.io:443".to_string(),\n        magic: 894710606,\n    };\n    \n    // Switch between networks\n    let client = RpcClient::new(HttpProvider::new(&mainnet.rpc_url)?);\n    let version = client.get_version().await?;\n    println!("Connected to: {}", version.useragent);\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"network-monitoring",children:(0,s.jsx)(n.strong,{children:"Network Monitoring"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use neo3::prelude::*;\n\nasync fn monitor_network() -> Result<(), Box<dyn std::error::Error>> {\n    let client = RpcClient::new(HttpProvider::new("https://mainnet1.neo.coz.io:443")?);\n    \n    // Monitor blockchain in real-time\n    let mut last_block = 0;\n    \n    loop {\n        let current_block = client.get_block_count().await?;\n        \n        if current_block > last_block {\n            let block = client.get_block_by_index(current_block - 1, 1).await?;\n            println!("New block #{}: {} ({} transactions)", \n                current_block, block.hash, block.tx.len());\n            last_block = current_block;\n        }\n        \n        tokio::time::sleep(tokio::time::Duration::from_secs(15)).await;\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"-security-features",children:["\ud83d\udd12 ",(0,s.jsx)(n.strong,{children:"Security Features"})]}),"\n",(0,s.jsx)(n.h3,{id:"secure-key-management",children:(0,s.jsx)(n.strong,{children:"Secure Key Management"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use neo3::prelude::*;\n\nasync fn secure_operations() -> Result<(), Box<dyn std::error::Error>> {\n    // Generate cryptographically secure keys\n    let private_key = PrivateKey::random()?;\n    let public_key = private_key.public_key();\n    let address = public_key.to_address();\n    \n    // Secure memory handling (keys are automatically cleared)\n    {\n        let sensitive_data = private_key.to_bytes();\n        // Use sensitive_data...\n    } // sensitive_data is automatically cleared here\n    \n    // Encrypt private key with password\n    let encrypted_key = private_key.encrypt("secure_password")?;\n    \n    // Decrypt when needed\n    let decrypted_key = PrivateKey::decrypt(&encrypted_key, "secure_password")?;\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"transaction-security",children:(0,s.jsx)(n.strong,{children:"Transaction Security"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use neo3::prelude::*;\n\nasync fn secure_transactions() -> Result<(), Box<dyn std::error::Error>> {\n    let client = RpcClient::new(HttpProvider::new("https://testnet1.neo.coz.io:443")?);\n    let account = Account::create()?;\n    \n    // Build transaction with security checks\n    let mut tx_builder = TransactionBuilder::new()\n        .version(0)\n        .nonce(rand::random())\n        .valid_until_block(client.get_block_count().await? + 100)\n        .sender(account.get_script_hash())\n        .system_fee(1000000)\n        .network_fee(1000000);\n    \n    // Add security validations\n    tx_builder.validate_fees()?;\n    tx_builder.validate_size()?;\n    \n    let transaction = tx_builder.build();\n    \n    // Sign with multiple security checks\n    let signed_tx = transaction.sign_with_validation(&account).await?;\n    \n    // Verify signature before sending\n    signed_tx.verify_signature()?;\n    \n    let tx_hash = client.send_raw_transaction(signed_tx).await?;\n    println!("Secure transaction sent: {}", tx_hash);\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"-performance-optimization",children:["\ud83d\udcca ",(0,s.jsx)(n.strong,{children:"Performance Optimization"})]}),"\n",(0,s.jsx)(n.h3,{id:"batch-operations",children:(0,s.jsx)(n.strong,{children:"Batch Operations"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use neo3::prelude::*;\n\nasync fn batch_operations() -> Result<(), Box<dyn std::error::Error>> {\n    let client = RpcClient::new(HttpProvider::new("https://testnet1.neo.coz.io:443")?);\n    \n    // Batch multiple RPC calls\n    let batch_requests = vec![\n        client.get_block_count_request(),\n        client.get_best_block_hash_request(),\n        client.get_version_request(),\n    ];\n    \n    let results = client.batch_request(batch_requests).await?;\n    \n    for (i, result) in results.iter().enumerate() {\n        println!("Batch request {}: {:?}", i, result);\n    }\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"connection-pooling",children:(0,s.jsx)(n.strong,{children:"Connection Pooling"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use neo3::prelude::*;\n\nasync fn connection_pooling() -> Result<(), Box<dyn std::error::Error>> {\n    // Create connection pool for high-throughput applications\n    let pool = ConnectionPool::new()\n        .max_connections(10)\n        .timeout(Duration::from_secs(30))\n        .build("https://mainnet1.neo.coz.io:443")?;\n    \n    // Use pooled connections\n    let client = RpcClient::new(pool);\n    \n    // Concurrent operations\n    let futures = (0..100).map(|_| {\n        let client = client.clone();\n        async move {\n            client.get_block_count().await\n        }\n    });\n    \n    let results = futures::future::join_all(futures).await;\n    println!("Completed {} concurrent requests", results.len());\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"-testing-framework",children:["\ud83e\uddea ",(0,s.jsx)(n.strong,{children:"Testing Framework"})]}),"\n",(0,s.jsx)(n.h3,{id:"unit-testing",children:(0,s.jsx)(n.strong,{children:"Unit Testing"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use neo3::prelude::*;\n\n#[tokio::test]\nasync fn test_wallet_creation() -> Result<(), Box<dyn std::error::Error>> {\n    let mut wallet = Wallet::new();\n    wallet.set_name("TestWallet".to_string());\n    \n    let account = Account::create()?;\n    wallet.add_account(account);\n    \n    assert_eq!(wallet.get_accounts().len(), 1);\n    assert_eq!(wallet.get_name(), "TestWallet");\n    \n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_transaction_building() -> Result<(), Box<dyn std::error::Error>> {\n    let account = Account::create()?;\n    \n    let transaction = TransactionBuilder::new()\n        .version(0)\n        .nonce(12345)\n        .valid_until_block(1000000)\n        .sender(account.get_script_hash())\n        .system_fee(1000000)\n        .network_fee(1000000)\n        .build();\n    \n    assert_eq!(transaction.version, 0);\n    assert_eq!(transaction.nonce, 12345);\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"integration-testing",children:(0,s.jsx)(n.strong,{children:"Integration Testing"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use neo3::prelude::*;\n\n#[tokio::test]\nasync fn test_blockchain_integration() -> Result<(), Box<dyn std::error::Error>> {\n    let client = RpcClient::new(HttpProvider::new("https://testnet1.neo.coz.io:443")?);\n    \n    // Test blockchain connectivity\n    let version = client.get_version().await?;\n    assert!(!version.useragent.is_empty());\n    \n    // Test block retrieval\n    let block_count = client.get_block_count().await?;\n    assert!(block_count > 0);\n    \n    let latest_block = client.get_block_by_index(block_count - 1, 1).await?;\n    assert!(!latest_block.hash.is_empty());\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"-advanced-examples",children:["\ud83d\udcda ",(0,s.jsx)(n.strong,{children:"Advanced Examples"})]}),"\n",(0,s.jsx)(n.h3,{id:"defi-integration",children:(0,s.jsx)(n.strong,{children:"DeFi Integration"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use neo3::prelude::*;\n\nasync fn defi_operations() -> Result<(), Box<dyn std::error::Error>> {\n    let client = RpcClient::new(HttpProvider::new("https://mainnet1.neo.coz.io:443")?);\n    \n    // Interact with Flamingo Finance\n    let flamingo = FlamingoContract::new(Some(&client));\n    \n    // Get swap rates\n    let gas_token = "0xd2a4cff31913016155e38e474a2c06d08be276cf".parse()?;\n    let neo_token = "0xef4073a0f2b305a38ec4050e4d3d28bc40ea63f5".parse()?;\n    \n    let swap_rate = flamingo.get_swap_rate(&gas_token, &neo_token, 1_0000_0000).await?;\n    println!("1 GAS = {} NEO", swap_rate as f64 / 100_000_000.0);\n    \n    // Get liquidity pool information\n    let pool_info = flamingo.get_pool_info(&gas_token, &neo_token).await?;\n    println!("Pool reserves: {} GAS, {} NEO", pool_info.reserve_a, pool_info.reserve_b);\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"enterprise-asset-management",children:(0,s.jsx)(n.strong,{children:"Enterprise Asset Management"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use neo3::prelude::*;\n\nasync fn enterprise_asset_management() -> Result<(), Box<dyn std::error::Error>> {\n    let client = RpcClient::new(HttpProvider::new("https://mainnet1.neo.coz.io:443")?);\n    let treasury_account = Account::from_wif("your-treasury-private-key")?;\n    \n    // Deploy corporate token\n    let corporate_token = Nep17Contract::deploy(\n        "CorporateToken",\n        "CORP",\n        8,\n        1_000_000_00000000, // 1 billion tokens\n        &treasury_account,\n        &client,\n    ).await?;\n    \n    // Batch distribute to employees\n    let employees = vec![\n        ("employee1@company.com", "NbTiM6h8r99kpRtb428XcsUk1TzKed2gTc", 10000_00000000),\n        ("employee2@company.com", "NX8GVjjjhyZNhMhmdBbg1KrP3tJ5cAqd2c", 15000_00000000),\n        ("employee3@company.com", "NY9WpJ3qKyqK8gLbTKrP3tJ5cAqd2c8X", 12000_00000000),\n    ];\n    \n    for (email, address, amount) in employees {\n        let recipient = address.parse()?;\n        corporate_token.transfer(\n            treasury_account.clone(),\n            recipient,\n            amount,\n            Some(format!("Salary payment for {}", email)),\n        ).await?;\n        \n        println!("Transferred {} CORP to {}", amount as f64 / 100_000_000.0, email);\n    }\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"-api-reference",children:["\ud83d\udd17 ",(0,s.jsx)(n.strong,{children:"API Reference"})]}),"\n",(0,s.jsx)(n.h3,{id:"core-types",children:(0,s.jsx)(n.strong,{children:"Core Types"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://docs.rs/neo3/latest/neo3/struct.Account.html",children:"Account"})}),": Cryptographic account management"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://docs.rs/neo3/latest/neo3/struct.Wallet.html",children:"Wallet"})}),": Multi-account wallet container"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://docs.rs/neo3/latest/neo3/struct.Transaction.html",children:"Transaction"})}),": Blockchain transaction representation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://docs.rs/neo3/latest/neo3/struct.RpcClient.html",children:"RpcClient"})}),": Blockchain RPC communication"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"contract-types",children:(0,s.jsx)(n.strong,{children:"Contract Types"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://docs.rs/neo3/latest/neo3/struct.SmartContract.html",children:"SmartContract"})}),": Generic smart contract interaction"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://docs.rs/neo3/latest/neo3/struct.Nep17Contract.html",children:"Nep17Contract"})}),": NEP-17 token standard"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://docs.rs/neo3/latest/neo3/struct.NftContract.html",children:"NftContract"})}),": NFT collection management"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://docs.rs/neo3/latest/neo3/struct.NameService.html",children:"NameService"})}),": Neo Name Service integration"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"utility-types",children:(0,s.jsx)(n.strong,{children:"Utility Types"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://docs.rs/neo3/latest/neo3/struct.PrivateKey.html",children:"PrivateKey"})}),": Private key operations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://docs.rs/neo3/latest/neo3/struct.PublicKey.html",children:"PublicKey"})}),": Public key operations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://docs.rs/neo3/latest/neo3/struct.ScriptHash.html",children:"ScriptHash"})}),": Script hash representation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://docs.rs/neo3/latest/neo3/struct.Address.html",children:"Address"})}),": Neo address format"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"-next-steps",children:["\ud83d\udcda ",(0,s.jsx)(n.strong,{children:"Next Steps"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./installation",children:"Installation Guide"})}),": Detailed setup instructions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./quick-start",children:"Quick Start"})}),": Get up and running in 5 minutes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./examples",children:"Examples"})}),": Real-world usage examples"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://docs.rs/neo3",children:"API Reference"})}),": Complete API documentation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./performance",children:"Performance Guide"})}),": Optimization techniques"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./security",children:"Security Best Practices"})}),": Keep your applications secure"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Ready to build production-ready Neo N3 applications?"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://docs.rs/neo3",children:"View Complete API Documentation \u2192"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},7843:(e,n,t)=>{t.d(n,{A:()=>r});const r="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjQwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8cmVjdCB3aWR0aD0iODAwIiBoZWlnaHQ9IjQwMCIgZmlsbD0iI2YzZjRmNiIvPgogIDxyZWN0IHg9IjUwIiB5PSI1MCIgd2lkdGg9IjcwMCIgaGVpZ2h0PSIzMDAiIGZpbGw9IiNkYzI2MjYiIHJ4PSIxMCIvPgogIDx0ZXh0IHg9IjQwMCIgeT0iMTgwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LWZhbWlseT0ibW9ub3NwYWNlIiBmb250LXNpemU9IjI0IiBmaWxsPSJ3aGl0ZSI+8J+mgCBSdXN0IFNESzwvdGV4dD4KICA8dGV4dCB4PSI0MDAiIHk9IjIyMCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjE2IiBmaWxsPSJ3aGl0ZSI+UHJvZHVjdGlvbi1SZWFkeSBMaWJyYXJ5PC90ZXh0Pgo8L3N2Zz4g"},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var r=t(6540);const s={},o=r.createContext(s);function i(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);