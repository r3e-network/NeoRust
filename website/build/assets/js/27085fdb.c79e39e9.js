"use strict";(self.webpackChunkneorust_website=self.webpackChunkneorust_website||[]).push([[3033],{3507:n=>{n.exports=JSON.parse('{"permalink":"/blog/building-first-neo-dapp","editUrl":"https://github.com/R3E-Network/NeoRust/tree/main/website/blog/2024-01-10-building-first-neo-dapp.md","source":"@site/blog/2024-01-10-building-first-neo-dapp.md","title":"\ud83c\udfd7\ufe0f Building Your First Neo dApp with NeoRust - Complete Guide","description":"Welcome to the complete guide for building your first decentralized application (dApp) on Neo N3 using NeoRust! In this tutorial, we\'ll create a simple but functional Token Voting dApp that demonstrates core Neo blockchain concepts.","date":"2024-01-10T00:00:00.000Z","tags":[{"inline":true,"label":"tutorial","permalink":"/blog/tags/tutorial"},{"inline":true,"label":"dapp","permalink":"/blog/tags/dapp"},{"inline":true,"label":"neo3","permalink":"/blog/tags/neo-3"},{"inline":true,"label":"rust","permalink":"/blog/tags/rust"},{"inline":true,"label":"beginner","permalink":"/blog/tags/beginner"}],"readingTime":11.29,"hasTruncateMarker":true,"authors":[{"name":"Sarah Chen","title":"Blockchain Engineer","url":"https://github.com/sarahchen","email":"sarah@neorust.org","imageURL":"/img/blog/authors/sarah-chen.jpg","key":"sarah-chen","page":null}],"frontMatter":{"slug":"building-first-neo-dapp","title":"\ud83c\udfd7\ufe0f Building Your First Neo dApp with NeoRust - Complete Guide","authors":["sarah-chen"],"tags":["tutorial","dapp","neo3","rust","beginner"]},"unlisted":false,"prevItem":{"title":"\ud83c\udf89 NeoRust v0.4.1 Released - Production-Ready Neo N3 Development","permalink":"/blog/neorust-v0.4.1-release"}}')},4627:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var o=t(3507),r=t(4848),s=t(8453);const a={slug:"building-first-neo-dapp",title:"\ud83c\udfd7\ufe0f Building Your First Neo dApp with NeoRust - Complete Guide",authors:["sarah-chen"],tags:["tutorial","dapp","neo3","rust","beginner"]},i="Building Your First Neo dApp with NeoRust \ud83c\udfd7\ufe0f",l={authorsImageUrls:[void 0]},c=[{value:"What We&#39;ll Build \ud83c\udfaf",id:"what-well-build-",level:2},{value:"Prerequisites \ud83d\udccb",id:"prerequisites-",level:2},{value:"Step 1: Project Setup \ud83d\udee0\ufe0f",id:"step-1-project-setup-\ufe0f",level:2},{value:"Step 2: Smart Contract Development \ud83d\udcdd",id:"step-2-smart-contract-development-",level:2},{value:"Creating the Contract",id:"creating-the-contract",level:3},{value:"Contract Implementation",id:"contract-implementation",level:3},{value:"Compile the Contract",id:"compile-the-contract",level:3},{value:"Step 3: Backend Service \ud83d\ude80",id:"step-3-backend-service-",level:2},{value:"Step 4: Frontend Development \ud83c\udfa8",id:"step-4-frontend-development-",level:2},{value:"Main Component (<code>src/App.tsx</code>):",id:"main-component-srcapptsx",level:3},{value:"Styling (<code>src/App.css</code>):",id:"styling-srcappcss",level:3},{value:"Step 5: Integration Tests \ud83e\uddea",id:"step-5-integration-tests-",level:2},{value:"Step 6: Deployment &amp; Testing \ud83d\ude80",id:"step-6-deployment--testing-",level:2},{value:"Deploy to TestNet",id:"deploy-to-testnet",level:3},{value:"Test the Complete Flow",id:"test-the-complete-flow",level:3},{value:"Advanced Features \ud83d\udd25",id:"advanced-features-",level:2},{value:"Add Real NEP-17 Token Integration",id:"add-real-nep-17-token-integration",level:3},{value:"Add Governance Features",id:"add-governance-features",level:3},{value:"Best Practices \ud83d\udcda",id:"best-practices-",level:2},{value:"Security Considerations",id:"security-considerations",level:3},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Testing Strategy",id:"testing-strategy",level:3},{value:"Troubleshooting \ud83d\udd27",id:"troubleshooting-",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"What&#39;s Next? \ud83d\udd2e",id:"whats-next-",level:2},{value:"Enhancements",id:"enhancements",level:3},{value:"Production Deployment",id:"production-deployment",level:3},{value:"Community Features",id:"community-features",level:3},{value:"Conclusion \ud83c\udf89",id:"conclusion-",level:2},{value:"Resources",id:"resources",level:3}];function p(n){const e={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.p,{children:["Welcome to the complete guide for building your first decentralized application (dApp) on Neo N3 using NeoRust! In this tutorial, we'll create a simple but functional ",(0,r.jsx)(e.strong,{children:"Token Voting dApp"})," that demonstrates core Neo blockchain concepts."]}),"\n",(0,r.jsx)(e.h2,{id:"what-well-build-",children:"What We'll Build \ud83c\udfaf"}),"\n",(0,r.jsxs)(e.p,{children:["Our ",(0,r.jsx)(e.strong,{children:"Token Voting dApp"})," will feature:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Smart Contract"}),": NEP-17 token with voting functionality"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Frontend"}),": React web interface for voting"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Backend"}),": Rust service for blockchain interaction"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Wallet Integration"}),": Connect with Neo wallets"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"By the end of this tutorial, you'll have a complete understanding of Neo dApp development!"}),"\n",(0,r.jsx)(e.h2,{id:"prerequisites-",children:"Prerequisites \ud83d\udccb"}),"\n",(0,r.jsx)(e.p,{children:"Before we start, ensure you have:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# Rust toolchain\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\n# Node.js for frontend\nnode --version  # v18+\n\n# NeoRust CLI\ncargo install neo3-cli\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Knowledge Requirements:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Basic Rust programming"}),"\n",(0,r.jsx)(e.li,{children:"Understanding of blockchain concepts"}),"\n",(0,r.jsx)(e.li,{children:"Familiarity with smart contracts"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"step-1-project-setup-\ufe0f",children:"Step 1: Project Setup \ud83d\udee0\ufe0f"}),"\n",(0,r.jsx)(e.p,{children:"Let's create our project structure:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:'mkdir neo-voting-dapp\ncd neo-voting-dapp\n\n# Create Rust workspace\ncat > Cargo.toml << EOF\n[workspace]\nmembers = [\n    "smart-contract",\n    "backend-service", \n    "integration-tests"\n]\nEOF\n\n# Create project directories\nmkdir smart-contract backend-service frontend integration-tests\n'})}),"\n",(0,r.jsx)(e.h2,{id:"step-2-smart-contract-development-",children:"Step 2: Smart Contract Development \ud83d\udcdd"}),"\n",(0,r.jsx)(e.h3,{id:"creating-the-contract",children:"Creating the Contract"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"cd smart-contract\ncargo init --lib\n"})}),"\n",(0,r.jsxs)(e.p,{children:["Add dependencies to ",(0,r.jsx)(e.code,{children:"Cargo.toml"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-toml",children:'[dependencies]\nneo3 = "0.4.1"\nserde = { version = "1.0", features = ["derive"] }\nserde_json = "1.0"\n\n[lib]\ncrate-type = ["cdylib"]\n'})}),"\n",(0,r.jsx)(e.h3,{id:"contract-implementation",children:"Contract Implementation"}),"\n",(0,r.jsxs)(e.p,{children:["Create ",(0,r.jsx)(e.code,{children:"src/lib.rs"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'use neo3::prelude::*;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n#[derive(Serialize, Deserialize, Clone)]\npub struct Proposal {\n    pub id: u32,\n    pub title: String,\n    pub description: String,\n    pub votes_for: u64,\n    pub votes_against: u64,\n    pub deadline: u64,\n    pub active: bool,\n}\n\n#[derive(Serialize, Deserialize)]\npub struct VotingContract {\n    owner: Address,\n    proposals: HashMap<u32, Proposal>,\n    voter_power: HashMap<Address, u64>,\n    next_proposal_id: u32,\n}\n\nimpl VotingContract {\n    #[neo3::init]\n    pub fn init(owner: Address) -> Self {\n        Self {\n            owner,\n            proposals: HashMap::new(),\n            voter_power: HashMap::new(),\n            next_proposal_id: 1,\n        }\n    }\n\n    #[neo3::method]\n    pub fn create_proposal(\n        &mut self,\n        title: String,\n        description: String,\n        voting_period: u64,\n    ) -> Result<u32, String> {\n        // Verify caller is owner\n        if Runtime::calling_script_hash() != self.owner.script_hash() {\n            return Err("Only owner can create proposals".to_string());\n        }\n\n        let proposal_id = self.next_proposal_id;\n        let deadline = Runtime::time() + voting_period;\n        \n        let proposal = Proposal {\n            id: proposal_id,\n            title,\n            description,\n            votes_for: 0,\n            votes_against: 0,\n            deadline,\n            active: true,\n        };\n\n        self.proposals.insert(proposal_id, proposal);\n        self.next_proposal_id += 1;\n\n        // Emit event\n        Runtime::notify(&[\n            "ProposalCreated".into(),\n            proposal_id.into(),\n            deadline.into(),\n        ]);\n\n        Ok(proposal_id)\n    }\n\n    #[neo3::method]\n    pub fn vote(\n        &mut self,\n        proposal_id: u32,\n        support: bool,\n    ) -> Result<(), String> {\n        let caller = Runtime::calling_script_hash();\n        \n        // Get voter power (based on token balance)\n        let power = self.get_voter_power(&caller)?;\n        if power == 0 {\n            return Err("No voting power".to_string());\n        }\n\n        // Get proposal\n        let proposal = self.proposals.get_mut(&proposal_id)\n            .ok_or("Proposal not found")?;\n\n        // Check if still active\n        if !proposal.active || Runtime::time() > proposal.deadline {\n            return Err("Proposal voting ended".to_string());\n        }\n\n        // Cast vote\n        if support {\n            proposal.votes_for += power;\n        } else {\n            proposal.votes_against += power;\n        }\n\n        // Emit vote event\n        Runtime::notify(&[\n            "VoteCast".into(),\n            caller.into(),\n            proposal_id.into(),\n            support.into(),\n            power.into(),\n        ]);\n\n        Ok(())\n    }\n\n    #[neo3::method]\n    pub fn get_proposal(&self, proposal_id: u32) -> Option<Proposal> {\n        self.proposals.get(&proposal_id).cloned()\n    }\n\n    #[neo3::method]\n    pub fn get_all_proposals(&self) -> Vec<Proposal> {\n        self.proposals.values().cloned().collect()\n    }\n\n    fn get_voter_power(&self, voter: &ScriptHash) -> Result<u64, String> {\n        // In a real contract, this would check NEP-17 token balance\n        // For demo, we\'ll use a simple power assignment\n        Ok(self.voter_power.get(&Address::from(*voter)).copied().unwrap_or(100))\n    }\n\n    #[neo3::method]\n    pub fn set_voter_power(&mut self, voter: Address, power: u64) -> Result<(), String> {\n        if Runtime::calling_script_hash() != self.owner.script_hash() {\n            return Err("Only owner can set voting power".to_string());\n        }\n        \n        self.voter_power.insert(voter, power);\n        Ok(())\n    }\n}\n\n// Export the contract\n#[neo3::contract]\npub fn main() -> VotingContract {\n    VotingContract::init(Runtime::calling_script_hash().into())\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"compile-the-contract",children:"Compile the Contract"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# Build the contract\ncargo build --release --target wasm32-unknown-unknown\n\n# Generate Neo contract files\nneo3-compiler compile \\\n  --input target/wasm32-unknown-unknown/release/smart_contract.wasm \\\n  --output voting-contract.nef\n"})}),"\n",(0,r.jsx)(e.h2,{id:"step-3-backend-service-",children:"Step 3: Backend Service \ud83d\ude80"}),"\n",(0,r.jsx)(e.p,{children:"Create a Rust service to interact with our smart contract:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"cd ../backend-service\ncargo init\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"Cargo.toml"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-toml",children:'[dependencies]\nneo3 = "0.4.1"\ntokio = { version = "1.0", features = ["full"] }\nwarp = "0.3"\nserde = { version = "1.0", features = ["derive"] }\nserde_json = "1.0"\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"src/main.rs"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'use neo3::prelude::*;\nuse serde::{Deserialize, Serialize};\nuse std::sync::Arc;\nuse warp::Filter;\n\n#[derive(Serialize, Deserialize)]\nstruct CreateProposalRequest {\n    title: String,\n    description: String,\n    voting_period: u64,\n}\n\n#[derive(Serialize, Deserialize)]\nstruct VoteRequest {\n    proposal_id: u32,\n    support: bool,\n}\n\n#[derive(Clone)]\nstruct AppState {\n    neo_client: Arc<RpcClient>,\n    contract_hash: ScriptHash,\n    owner_account: Account,\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Initialize Neo client\n    let provider = HttpProvider::new("https://testnet1.neo.org:443")?;\n    let client = RpcClient::new(provider);\n    \n    // Load contract and owner account\n    let contract_hash = ScriptHash::from_str("0x1234...contract_hash...")?;\n    let owner_account = Account::from_wif("your_private_key_wif")?;\n    \n    let state = AppState {\n        neo_client: Arc::new(client),\n        contract_hash,\n        owner_account,\n    };\n\n    // API Routes\n    let create_proposal = warp::path("api")\n        .and(warp::path("proposals"))\n        .and(warp::post())\n        .and(warp::body::json())\n        .and(with_state(state.clone()))\n        .and_then(create_proposal_handler);\n\n    let vote = warp::path("api")\n        .and(warp::path("vote"))\n        .and(warp::post())\n        .and(warp::body::json())\n        .and(with_state(state.clone()))\n        .and_then(vote_handler);\n\n    let get_proposals = warp::path("api")\n        .and(warp::path("proposals"))\n        .and(warp::get())\n        .and(with_state(state.clone()))\n        .and_then(get_proposals_handler);\n\n    let cors = warp::cors()\n        .allow_any_origin()\n        .allow_headers(vec!["content-type"])\n        .allow_methods(vec!["GET", "POST", "OPTIONS"]);\n\n    let routes = create_proposal\n        .or(vote)\n        .or(get_proposals)\n        .with(cors);\n\n    println!("\ud83d\ude80 Server running on http://localhost:3001");\n    warp::serve(routes).run(([127, 0, 0, 1], 3001)).await;\n    \n    Ok(())\n}\n\nfn with_state(state: AppState) -> impl Filter<Extract = (AppState,), Error = std::convert::Infallible> + Clone {\n    warp::any().map(move || state.clone())\n}\n\nasync fn create_proposal_handler(\n    req: CreateProposalRequest,\n    state: AppState,\n) -> Result<impl warp::Reply, warp::Rejection> {\n    match create_proposal(req, state).await {\n        Ok(proposal_id) => Ok(warp::reply::json(&serde_json::json!({\n            "success": true,\n            "proposal_id": proposal_id\n        }))),\n        Err(e) => Ok(warp::reply::json(&serde_json::json!({\n            "success": false,\n            "error": e.to_string()\n        }))),\n    }\n}\n\nasync fn vote_handler(\n    req: VoteRequest,\n    state: AppState,\n) -> Result<impl warp::Reply, warp::Rejection> {\n    match cast_vote(req, state).await {\n        Ok(_) => Ok(warp::reply::json(&serde_json::json!({\n            "success": true\n        }))),\n        Err(e) => Ok(warp::reply::json(&serde_json::json!({\n            "success": false,\n            "error": e.to_string()\n        }))),\n    }\n}\n\nasync fn get_proposals_handler(\n    state: AppState,\n) -> Result<impl warp::Reply, warp::Rejection> {\n    match get_all_proposals(state).await {\n        Ok(proposals) => Ok(warp::reply::json(&proposals)),\n        Err(e) => Ok(warp::reply::json(&serde_json::json!({\n            "error": e.to_string()\n        }))),\n    }\n}\n\nasync fn create_proposal(\n    req: CreateProposalRequest,\n    state: AppState,\n) -> Result<u32, Box<dyn std::error::Error>> {\n    let transaction = TransactionBuilder::new()\n        .add_contract_call(\n            state.contract_hash,\n            "create_proposal",\n            vec![\n                req.title.into(),\n                req.description.into(),\n                req.voting_period.into(),\n            ],\n        )?\n        .add_signer(state.owner_account.get_script_hash())?\n        .build()?;\n\n    let signed_tx = state.owner_account.sign_transaction(transaction)?;\n    let result = state.neo_client.send_raw_transaction(signed_tx).await?;\n    \n    // Parse proposal ID from result\n    Ok(1) // Simplified for demo\n}\n\nasync fn cast_vote(\n    req: VoteRequest,\n    state: AppState,\n) -> Result<(), Box<dyn std::error::Error>> {\n    let transaction = TransactionBuilder::new()\n        .add_contract_call(\n            state.contract_hash,\n            "vote",\n            vec![\n                req.proposal_id.into(),\n                req.support.into(),\n            ],\n        )?\n        .add_signer(state.owner_account.get_script_hash())?\n        .build()?;\n\n    let signed_tx = state.owner_account.sign_transaction(transaction)?;\n    state.neo_client.send_raw_transaction(signed_tx).await?;\n    \n    Ok(())\n}\n\nasync fn get_all_proposals(\n    state: AppState,\n) -> Result<Vec<serde_json::Value>, Box<dyn std::error::Error>> {\n    let result = state.neo_client\n        .invoke_function(\n            state.contract_hash,\n            "get_all_proposals",\n            vec![],\n        )\n        .await?;\n    \n    // Parse and return proposals\n    Ok(vec![]) // Simplified for demo\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"step-4-frontend-development-",children:"Step 4: Frontend Development \ud83c\udfa8"}),"\n",(0,r.jsx)(e.p,{children:"Create a React frontend:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"cd ../frontend\nnpx create-react-app . --template typescript\nnpm install @cityofzion/wallet-connect-sdk-react axios\n"})}),"\n",(0,r.jsxs)(e.h3,{id:"main-component-srcapptsx",children:["Main Component (",(0,r.jsx)(e.code,{children:"src/App.tsx"}),"):"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"import React, { useState, useEffect } from 'react';\nimport { WalletConnectSDK } from '@cityofzion/wallet-connect-sdk-react';\nimport axios from 'axios';\nimport './App.css';\n\ninterface Proposal {\n  id: number;\n  title: string;\n  description: string;\n  votes_for: number;\n  votes_against: number;\n  deadline: number;\n  active: boolean;\n}\n\nfunction App() {\n  const [proposals, setProposals] = useState<Proposal[]>([]);\n  const [connected, setConnected] = useState(false);\n  const [loading, setLoading] = useState(false);\n\n  const walletConnect = new WalletConnectSDK({\n    projectId: 'your_project_id',\n    metadata: {\n      name: 'Neo Voting dApp',\n      description: 'Decentralized voting on Neo blockchain',\n      url: 'https://yourapp.com',\n      icons: ['https://yourapp.com/icon.png']\n    }\n  });\n\n  useEffect(() => {\n    loadProposals();\n  }, []);\n\n  const loadProposals = async () => {\n    try {\n      const response = await axios.get('http://localhost:3001/api/proposals');\n      setProposals(response.data);\n    } catch (error) {\n      console.error('Failed to load proposals:', error);\n    }\n  };\n\n  const connectWallet = async () => {\n    try {\n      await walletConnect.connect();\n      setConnected(true);\n    } catch (error) {\n      console.error('Failed to connect wallet:', error);\n    }\n  };\n\n  const vote = async (proposalId: number, support: boolean) => {\n    if (!connected) {\n      alert('Please connect your wallet first');\n      return;\n    }\n\n    setLoading(true);\n    try {\n      await axios.post('http://localhost:3001/api/vote', {\n        proposal_id: proposalId,\n        support\n      });\n      \n      await loadProposals(); // Refresh\n      alert('Vote cast successfully!');\n    } catch (error) {\n      console.error('Failed to vote:', error);\n      alert('Failed to cast vote');\n    }\n    setLoading(false);\n  };\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <h1>\ud83d\uddf3\ufe0f Neo Voting dApp</h1>\n        {!connected ? (\n          <button onClick={connectWallet} className=\"connect-btn\">\n            Connect Wallet\n          </button>\n        ) : (\n          <span className=\"connected\">\u2705 Wallet Connected</span>\n        )}\n      </header>\n\n      <main className=\"proposals-container\">\n        <h2>Active Proposals</h2>\n        {proposals.length === 0 ? (\n          <p>No proposals available</p>\n        ) : (\n          proposals.map(proposal => (\n            <div key={proposal.id} className=\"proposal-card\">\n              <h3>{proposal.title}</h3>\n              <p>{proposal.description}</p>\n              \n              <div className=\"voting-stats\">\n                <div className=\"vote-count\">\n                  \ud83d\udc4d For: {proposal.votes_for}\n                </div>\n                <div className=\"vote-count\">\n                  \ud83d\udc4e Against: {proposal.votes_against}\n                </div>\n              </div>\n\n              <div className=\"voting-buttons\">\n                <button\n                  onClick={() => vote(proposal.id, true)}\n                  disabled={loading || !proposal.active}\n                  className=\"vote-btn vote-for\"\n                >\n                  Vote For\n                </button>\n                <button\n                  onClick={() => vote(proposal.id, false)}\n                  disabled={loading || !proposal.active}\n                  className=\"vote-btn vote-against\"\n                >\n                  Vote Against\n                </button>\n              </div>\n\n              <div className=\"proposal-status\">\n                {proposal.active ? '\ud83d\udfe2 Active' : '\ud83d\udd34 Ended'}\n                <span className=\"deadline\">\n                  Deadline: {new Date(proposal.deadline * 1000).toLocaleDateString()}\n                </span>\n              </div>\n            </div>\n          ))\n        )}\n      </main>\n    </div>\n  );\n}\n\nexport default App;\n"})}),"\n",(0,r.jsxs)(e.h3,{id:"styling-srcappcss",children:["Styling (",(0,r.jsx)(e.code,{children:"src/App.css"}),"):"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-css",children:".App {\n  text-align: center;\n  min-height: 100vh;\n  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n  color: white;\n}\n\n.App-header {\n  padding: 2rem;\n  border-bottom: 1px solid rgba(255, 255, 255, 0.1);\n}\n\n.connect-btn {\n  background: #10b981;\n  color: white;\n  border: none;\n  padding: 12px 24px;\n  border-radius: 8px;\n  font-size: 16px;\n  cursor: pointer;\n  transition: background 0.3s;\n}\n\n.connect-btn:hover {\n  background: #059669;\n}\n\n.connected {\n  color: #10b981;\n  font-weight: bold;\n}\n\n.proposals-container {\n  max-width: 800px;\n  margin: 0 auto;\n  padding: 2rem;\n}\n\n.proposal-card {\n  background: rgba(255, 255, 255, 0.1);\n  border-radius: 12px;\n  padding: 1.5rem;\n  margin: 1rem 0;\n  text-align: left;\n  backdrop-filter: blur(10px);\n}\n\n.voting-stats {\n  display: flex;\n  gap: 2rem;\n  margin: 1rem 0;\n}\n\n.vote-count {\n  font-size: 18px;\n  font-weight: bold;\n}\n\n.voting-buttons {\n  display: flex;\n  gap: 1rem;\n  margin: 1rem 0;\n}\n\n.vote-btn {\n  padding: 10px 20px;\n  border: none;\n  border-radius: 6px;\n  font-weight: bold;\n  cursor: pointer;\n  transition: all 0.3s;\n}\n\n.vote-for {\n  background: #10b981;\n  color: white;\n}\n\n.vote-against {\n  background: #ef4444;\n  color: white;\n}\n\n.vote-btn:hover:not(:disabled) {\n  transform: translateY(-2px);\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n}\n\n.vote-btn:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n\n.proposal-status {\n  display: flex;\n  justify-content: space-between;\n  margin-top: 1rem;\n  font-size: 14px;\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"step-5-integration-tests-",children:"Step 5: Integration Tests \ud83e\uddea"}),"\n",(0,r.jsx)(e.p,{children:"Create comprehensive tests:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"cd ../integration-tests\ncargo init\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"src/main.rs"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'use neo3::prelude::*;\nuse tokio;\n\n#[tokio::test]\nasync fn test_full_voting_flow() -> Result<(), Box<dyn std::error::Error>> {\n    // Setup test environment\n    let provider = HttpProvider::new("http://localhost:20332")?; // Local testnet\n    let client = RpcClient::new(provider);\n    \n    // Deploy contract\n    let contract_hash = deploy_voting_contract(&client).await?;\n    \n    // Test proposal creation\n    let proposal_id = create_test_proposal(&client, contract_hash).await?;\n    assert_eq!(proposal_id, 1);\n    \n    // Test voting\n    cast_test_vote(&client, contract_hash, proposal_id, true).await?;\n    \n    // Verify vote was recorded\n    let proposal = get_proposal(&client, contract_hash, proposal_id).await?;\n    assert!(proposal.votes_for > 0);\n    \n    println!("\u2705 All tests passed!");\n    Ok(())\n}\n\nasync fn deploy_voting_contract(client: &RpcClient) -> Result<ScriptHash, Box<dyn std::error::Error>> {\n    // Contract deployment logic\n    todo!("Implement contract deployment")\n}\n\nasync fn create_test_proposal(client: &RpcClient, contract_hash: ScriptHash) -> Result<u32, Box<dyn std::error::Error>> {\n    // Proposal creation logic\n    todo!("Implement proposal creation test")\n}\n\nasync fn cast_test_vote(client: &RpcClient, contract_hash: ScriptHash, proposal_id: u32, support: bool) -> Result<(), Box<dyn std::error::Error>> {\n    // Voting logic\n    todo!("Implement voting test")\n}\n\n#[derive(Debug)]\nstruct Proposal {\n    votes_for: u64,\n    votes_against: u64,\n}\n\nasync fn get_proposal(client: &RpcClient, contract_hash: ScriptHash, proposal_id: u32) -> Result<Proposal, Box<dyn std::error::Error>> {\n    // Get proposal logic\n    todo!("Implement get proposal test")\n}\n\nfn main() {\n    println!("Run tests with: cargo test");\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"step-6-deployment--testing-",children:"Step 6: Deployment & Testing \ud83d\ude80"}),"\n",(0,r.jsx)(e.h3,{id:"deploy-to-testnet",children:"Deploy to TestNet"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# Deploy smart contract\ncd smart-contract\nneo3-cli deploy \\\n  --nef voting-contract.nef \\\n  --manifest voting-contract.manifest.json \\\n  --testnet\n\n# Start backend service\ncd ../backend-service\ncargo run\n\n# Start frontend\ncd ../frontend\nnpm start\n"})}),"\n",(0,r.jsx)(e.h3,{id:"test-the-complete-flow",children:"Test the Complete Flow"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Connect Wallet"}),": Use NeoLine or O3 wallet"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Create Proposal"}),": Call backend API"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Cast Votes"}),": Interact through frontend"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"View Results"}),": Real-time updates"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"advanced-features-",children:"Advanced Features \ud83d\udd25"}),"\n",(0,r.jsx)(e.h3,{id:"add-real-nep-17-token-integration",children:"Add Real NEP-17 Token Integration"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'// In smart contract\n#[neo3::method]\npub fn get_voter_power(&self, voter: &Address) -> Result<u64, String> {\n    // Get actual token balance\n    let token_contract = ScriptHash::from_str("0x...token_contract...")?;\n    let balance: u64 = Runtime::call_contract(\n        token_contract,\n        "balanceOf",\n        vec![voter.into()]\n    )?;\n    \n    Ok(balance / 100000000) // Convert from smallest unit\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"add-governance-features",children:"Add Governance Features"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'#[neo3::method]\npub fn execute_proposal(&mut self, proposal_id: u32) -> Result<(), String> {\n    let proposal = self.proposals.get(&proposal_id)\n        .ok_or("Proposal not found")?;\n    \n    // Check if proposal passed\n    if proposal.votes_for > proposal.votes_against {\n        // Execute proposal logic\n        self.execute_governance_action(proposal)?;\n    }\n    \n    Ok(())\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"best-practices-",children:"Best Practices \ud83d\udcda"}),"\n",(0,r.jsx)(e.h3,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Input Validation"}),": Always validate user inputs"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Access Control"}),": Implement proper permission checks"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Reentrancy Protection"}),": Prevent recursive calls"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Integer Overflow"}),": Use safe math operations"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Gas Efficiency"}),": Minimize storage operations"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Batch Operations"}),": Group multiple calls"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Caching"}),": Cache frequently accessed data"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Event Indexing"}),": Use events for efficient querying"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"testing-strategy",children:"Testing Strategy"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Unit Tests"}),": Test individual functions"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Integration Tests"}),": Test contract interactions"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"End-to-End Tests"}),": Test complete user flows"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Security Audits"}),": Regular security reviews"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"troubleshooting-",children:"Troubleshooting \ud83d\udd27"}),"\n",(0,r.jsx)(e.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Contract Deployment Fails"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# Check network connection\nneo3-cli network status\n\n# Verify contract compilation\nneo3-compiler validate voting-contract.nef\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Frontend Can't Connect"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// Enable CORS in backend\napp.use(cors({\n  origin: "http://localhost:3000",\n  credentials: true\n}));\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Wallet Connection Issues"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"// Check wallet compatibility\nif (!window.NEOLine) {\n  alert('Please install NeoLine wallet');\n  return;\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"whats-next-",children:"What's Next? \ud83d\udd2e"}),"\n",(0,r.jsx)(e.p,{children:"Congratulations! You've built a complete Neo dApp. Here are next steps:"}),"\n",(0,r.jsx)(e.h3,{id:"enhancements",children:"Enhancements"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Mobile App"}),": React Native version"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Advanced UI"}),": Better design and animations"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Real-time Updates"}),": WebSocket integration"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Multi-language"}),": i18n support"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"production-deployment",children:"Production Deployment"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"MainNet Deployment"}),": Deploy to production"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"CDN Integration"}),": Optimize frontend delivery"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Monitoring"}),": Add application monitoring"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Security Audit"}),": Professional security review"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"community-features",children:"Community Features"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"DAO Integration"}),": Full DAO functionality"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Token Distribution"}),": Airdrop mechanisms"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Staking Rewards"}),": Incentive mechanisms"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Governance Evolution"}),": Advanced governance features"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"conclusion-",children:"Conclusion \ud83c\udf89"}),"\n",(0,r.jsx)(e.p,{children:"You've successfully built a complete Neo dApp with:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"\u2705 Smart contract with voting logic"}),"\n",(0,r.jsx)(e.li,{children:"\u2705 Rust backend service"}),"\n",(0,r.jsx)(e.li,{children:"\u2705 React frontend interface"}),"\n",(0,r.jsx)(e.li,{children:"\u2705 Wallet integration"}),"\n",(0,r.jsx)(e.li,{children:"\u2705 Testing framework"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Key Learnings:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Neo N3 smart contract development"}),"\n",(0,r.jsx)(e.li,{children:"NeoRust SDK capabilities"}),"\n",(0,r.jsx)(e.li,{children:"Full-stack dApp architecture"}),"\n",(0,r.jsx)(e.li,{children:"Blockchain integration patterns"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"resources",children:"Resources"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.a,{href:"../docs",children:"NeoRust Documentation"})}),": Complete API reference"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.a,{href:"https://developers.neo.org",children:"Neo Developer Hub"})}),": Official Neo resources"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.a,{href:"https://discord.gg/neo-rust",children:"Community Discord"})}),": Get help and connect"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.a,{href:"https://github.com/R3E-Network/NeoRust",children:"GitHub Repository"})}),": Source code and examples"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Ready to build more amazing dApps?"})," \ud83d\ude80"]}),"\n",(0,r.jsx)(e.p,{children:"Share your creation with the community and let's build the future of decentralized applications together!"}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsxs)(e.em,{children:["Follow ",(0,r.jsx)(e.a,{href:"https://twitter.com/neorustSDK",children:"@NeoRustSDK"})," for more tutorials and updates!"]})," \ud83e\udd80\u26a1\ufe0f"]})]})}function d(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(p,{...n})}):p(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>i});var o=t(6540);const r={},s=o.createContext(r);function a(n){const e=o.useContext(s);return o.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function i(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:a(n.components),o.createElement(s.Provider,{value:e},n.children)}}}]);